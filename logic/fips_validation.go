package logic

import (
    "crypto/ecdsa"
    "crypto/elliptic"
    "crypto/rand"
    "encoding/base64"
    "errors"
    "fmt"
    "math/big"

    "github.com/gravitl/netmaker/metrics"
)

// ValidatePublicKey ensures that keyB64 is a valid uncompressed P-256 key
// in base64 form. It returns a detailed error if it's invalid at any step.
func ValidatePublicKey(keyB64 string) error {
    // 1. Base64 decode
    decoded, err := base64.StdEncoding.DecodeString(keyB64)
    if err != nil {
        metrics.KeysValidated.WithLabelValues("invalid").Inc()
        return fmt.Errorf("invalid base64 encoding: %w", err)
    }
    // 2. Check length
    if len(decoded) != 65 {
        metrics.KeysValidated.WithLabelValues("invalid").Inc()
        return fmt.Errorf("invalid key length: got %d bytes, expected 65", len(decoded))
    }
    // 3. Check uncompressed prefix (0x04)
    if decoded[0] != 0x04 {
        metrics.KeysValidated.WithLabelValues("invalid").Inc()
        return fmt.Errorf("invalid key prefix: expected 0x04, got 0x%02x", decoded[0])
    }
    // 4. On-curve check using Go's elliptic (safe because public key was generated by wolfCrypt)
    x, y := elliptic.Unmarshal(elliptic.P256(), decoded)
    if x == nil || y == nil {
        metrics.KeysValidated.WithLabelValues("invalid").Inc()
        return errors.New("invalid P-256 key: point not on the curve")
    }
    metrics.KeysValidated.WithLabelValues("valid").Inc()
    return nil
}

// NOTE: The following two functions (GenerateP256KeyPair & Serialize/Deserialize)
// MUST be implemented by invoking wolfCrypt's FIPS API (either via CGO or a helper).
// Here we show a stub using Go's crypto/ecdsa, but in production you must replace
// this with wolfCrypt's wc_ecc_make_key() + wc_ecc_export_x963() + wc_ecc_export_private_only().

// GenerateP256KeyPair is a placeholder that uses Go's ecdsa. **Do NOT use this in prod.**
func GenerateP256KeyPair() (*ecdsa.PrivateKey, string, error) {
    // In production, call wolfCrypt's ECC generation:
    //   WC_RNG rng; ecc_key key; wc_InitRng(&rng); wc_ecc_init(&key)
    //   wc_ecc_make_key(&rng, 32, &key)
    //   wc_ecc_export_x963(&key, pubRaw, &pubSz)
    //   wc_ecc_export_private_only(&key, privRaw, &privSz)
    //   â†’ return privRaw (32 bytes) & pubRaw (65 bytes)
    //
    // Here, we generate with Go's standard library for demo / testing only:
    priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
    if err != nil {
        return nil, "", fmt.Errorf("failed to generate P-256 key pair: %w", err)
    }
    pubRaw := elliptic.Marshal(elliptic.P256(), priv.PublicKey.X, priv.PublicKey.Y)
    pubB64 := base64.StdEncoding.EncodeToString(pubRaw)
    return priv, pubB64, nil
}

// SerializeP256PrivateKey is a helper to serialize a 32-byte private key (big-endian) as base64.
// **In production, after generating via wolfCrypt, you would just base64-encode the 32 raw bytes.**
func SerializeP256PrivateKey(priv *ecdsa.PrivateKey) (string, error) {
    if priv == nil {
        return "", errors.New("cannot serialize nil private key")
    }
    privBytes := priv.D.Bytes()
    if len(privBytes) > 32 {
        return "", fmt.Errorf("unexpected private key size: %d bytes", len(privBytes))
    }
    padded := make([]byte, 32)
    copy(padded[32-len(privBytes):], privBytes)
    return base64.StdEncoding.EncodeToString(padded), nil
}

// DeserializeP256PrivateKey decodes a 32-byte base64 private key into *ecdsa.PrivateKey.
// **In production, this would reconstitute a wolfCrypt ECC structure if needed.**
func DeserializeP256PrivateKey(privB64 string) (*ecdsa.PrivateKey, error) {
    decoded, err := base64.StdEncoding.DecodeString(privB64)
    if err != nil {
        return nil, fmt.Errorf("invalid base64 for private key: %w", err)
    }
    if len(decoded) != 32 {
        return nil, fmt.Errorf("invalid private key length: got %d bytes, expected 32", len(decoded))
    }
    D := new(big.Int).SetBytes(decoded)
    priv := new(ecdsa.PrivateKey)
    priv.PublicKey.Curve = elliptic.P256()
    priv.D = D
    priv.PublicKey.X, priv.PublicKey.Y = priv.PublicKey.Curve.ScalarBaseMult(decoded)
    if priv.PublicKey.X == nil || priv.PublicKey.Y == nil {
        return nil, errors.New("failed to derive public key from private key bytes")
    }
    return priv, nil
} 